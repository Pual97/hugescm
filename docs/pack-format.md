# HugeSCM 打包文件格式

当我们实现了 HugeSCM 的基本功能之后，我们也逐渐考虑到应当实现对象打包机制，从而减少打开的文件数量，从而提高各种操作的效率。在借鉴了 git 的打包格式之后，结合 HugeSCM 自身的特性，我们引入了自己的打包格式，这里需要注意，在打包格式按照大端存储。

+ 4 字节签名 'P', 'A', 'C', 'K'
+ 4 字节版本信息, 当前版本为: 'Z'
+ 4 字节条目数量（N），在一个包中，对象的数量不能超过 4294967296 个。
+ N 个条目（4 字节长度 + 对象内容）。
+ 32 字节 BLAKE3 校验和

文件名为打包文件的 BLAKE3 哈希值，如： `pack-18bdc1a5ac3123aa7252cb81739fe0c9d2455e45ac8c34e285bdeffdf12df3bb.pack`，鉴于 metadata 和 blob 的特点，我们会采用不同的机制打包这些对象。由于我们将 BLOB 和 Metadata 分别存储，并且在这些对象中都存在 magic（或 ZSTD magic），因此我们有完整的类型检测机制，也就不用担心对象的识别。

## Metadata 条目
+ 4 字节 metadata 后续的对象在 pack 中占据的长度，值为 N。
+ N 字节 metadata 压缩（或原始）内容。如果是压缩存储，则采用存储库设置的压缩算法。

## Blob 条目

+ 4 字节 blob 对象长度，值为 N。
+ N 字节 blob 对象内容，在 blob pack 中，我们将松散对象原样复制到 pack 文件中。

## Pack Index 格式
+ 4 字节签名 '0xff', '0x74', '0x4f', '0x63'
+ 4 字节版本信息, 当前版本为: 'Z'
+ 4 字节 * 256 Fanout 表，记录了不大于它的对象的数量，比如 00 代表 OID（`[32]byte`） 第一位为 0 的 OID 数量，而 01 则是包含 `00-01` 对象的数量之和，最后则代表 pack 文件中的总条目（N）。 
+ N 个对象 Hash 存储，每条目 32 字节。
+ N 个对象最后修改时间，每条目 4 字节。
+ N 个对象 CRC32 存储，使用 IEEE 风格，每条目 4 字节。
+ N 个对象在包中的 32 位（4 字节）偏移，如果对象的偏移大于 2GB，则该值与 `0x7fffffff` 进行 `&` 运算，得到 64 位偏移的索引。
+ M 个对象在包中的 64 位（8 字节）偏移。
+ 32 字节包文件 BLAKE3 校验和。
+ 32 字节 Index 文件 BLAKE3 校验和。

## 与 Git 打包文件格式的差异

在流行的版本控制系统 Git 中，同样存在打包文件，虽然 HugeSCM 借鉴了 git 大量设计，但也会从实际情况出发，针对 HugeSCM 的特性调整设计。比如，HugeSCM 会将 metadata（tree/commit）和 blob 分开存储，不像 git 那样存储在一起，这是因为，对于 commit/tree 这些对象，我们最终会将其存储到 Database，对于 BLOB，最终会将其存储到 OSS，这些数据事实上被分流了，因此我们在实现客户端的时候也对其进行分流。并保留清理不同的策略。

此外，从实践来看，将大文件打包到 pack 文件中，是一个低效的操作，大量的二进制文件使得 pack 文件打包困难，体积巨大，传输容易失败。在 HugeSCM 中，无论是 Push 还是 checkout，对于体积超过 4G 的文件都需要使用额外的接口进行操作，因此在打包文件中，我们同样不支持超过 4G 的对象，这与 git 显著不同。此外，HugeSCM 是一种集中式的版本控制系统，并不是非常需要在打包中引入 Delta 机制以节省空间，如果需要节省空间直接删除不需要的对象即可。因此我们对打包格式的设计是保持简单和高效。 